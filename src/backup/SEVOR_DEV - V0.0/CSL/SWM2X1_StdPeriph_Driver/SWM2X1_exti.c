/****************************************************************************************************************************************** 
* �ļ��  ��:	SWM2X1_exti.c
* ���  ˵��:	SWM2X1��Ƭ�����ⲿ�жϹ���������
* ����֧��: http://www.synwit.com.cn/e/tool/gbook/?bid=1
* ע������:
* �汾����    V1.0.0		2016��1��30��
* ������¼:  
*
*******************************************************************************************************************************************
* @attention
*
* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS WITH CODING INFORMATION 
* REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME. AS A RESULT, SYNWIT SHALL NOT BE HELD LIABLE 
* FOR ANY DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE CONTENT 
* OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING INFORMATION CONTAINED HEREIN IN CONN-
* -ECTION WITH THEIR PRODUCTS.
*
* COPYRIGHT 2012 Synwit Technology 
*******************************************************************************************************************************************/
#include "SWM2X1.h"
#include "SWM2X1_exti.h"


/****************************************************************************************************************************************** 
* ��������: EXTI_Init()
* ���  ˵��:	ָ�������ⲿ�жϳ�ʼ��
* ��    ��: GPIO_TypeDef  * GPIOx	ָ�������ⲿ�жϵ�GPIO�˿ڣ���Чֵ����GPIOA��GPIOB��GPIOM
*      uint32_t n        ָ�������ⲿ�жϵ�GPIO���ţ���Чֵ����PIN0��PIN1��PIN2��... ... PIN14��PIN15
*      uint32_t mode     ��Чֵ��EXTI_FALL_EDGE��EXTI_RISE_EDGE��EXTI_BOTH_EDGE��EXTI_LOW_LEVEL��EXTI_HIGH_LEVEL
* ��    ��: ��
* ע������: ��
******************************************************************************************************************************************/
void EXTI_Init(GPIO_TypeDef * GPIOx, uint32_t n, uint32_t mode)
{
  EXTI_Close(GPIOx, n);      //���ùؼ��Ĵ���ǰ�ȹر�
  
  if(mode & 0x10)
  {
    GPIOx->INTLVLTRG |= (0x01 << n);      //��ƽ����
    
    if(mode & 0x01)
      GPIOx->INTRISEEN |= (0x01 << n);        //�ߵ�ƽ����
    else
      GPIOx->INTRISEEN &= ~(0x01 << n);        //�͵�ƽ����
  }    
  else
  {
    GPIOx->INTLVLTRG &= ~(0x01 << n);      //���ش���
    
    if(mode & 0x02)
    {
      GPIOx->INTBE |= (0x01 << n);        //˫���  ���	
    }
    else
    {
      GPIOx->INTBE &= ~(0x01 << n);        //�����ش���
      
      if(mode & 0x01)
        GPIOx->INTRISEEN |= (0x01 << n);      //�����ش���
      else
        GPIOx->INTRISEEN &= ~(0x01 << n);      //�½��ش���
    }
  }
  
  GPIOx->INTCLR = (1 << n);    //�������Ϊģʽ���ÿ��ܲ������ж�
}

/****************************************************************************************************************************************** 
* ���  ����:	EXTI_Open()
* ���  ˵��:	ָ�������ⲿ�жϴ򿪣���ʹ�ܣ�
* ��    ��: GPIO_TypeDef  * GPIOx	ָ�������ⲿ�жϵ�GPIO�˿ڣ���Чֵ����GPIOA��GPIOB��GPIOM
*      uint32_t n        ָ�������ⲿ�жϵ�GPIO���ţ���Чֵ����PIN0��PIN1��PIN2��... ... PIN14��PIN15
* ��    ��: ��
* ע������: ��
******************************************************************************************************************************************/
void EXTI_Open(GPIO_TypeDef * GPIOx, uint32_t n)
{
  GPIOx->INTEN |= (0x01 << n);
}

/****************************************************************************************************************************************** 
* ���  ����:	EXTI_Close()
* ���  ˵��:	ָ�������ⲿ�жϹرգ������ܣ�
* ��    ��: GPIO_TypeDef  * GPIOx	ָ�������ⲿ�жϵ�GPIO�˿ڣ���Чֵ����GPIOA��GPIOB��GPIOM
*      uint32_t n        ָ�������ⲿ�жϵ�GPIO���ţ���Чֵ����PIN0��PIN1��PIN2��... ... PIN14��PIN15
* ��    ��: ��
* ע������: ��
******************************************************************************************************************************************/
void EXTI_Close(GPIO_TypeDef * GPIOx, uint32_t n)
{
  GPIOx->INTEN &= ~(0x01 << n);
}

/****************************************************************************************************************************************** 
* ���  ����:	EXTI_State()
* ���  ˵��:	ָ�������Ƿ񴥷����ж�
* ��    ��: GPIO_TypeDef  * GPIOx	ָ�������ⲿ�жϵ�GPIO�˿ڣ���Чֵ����GPIOA��GPIOB��GPIOM
*      uint32_t n        ָ�������ⲿ�жϵ�GPIO���ţ���Чֵ����PIN0��PIN1��PIN2��... ... PIN14��PIN15
* ��    ��:   int32_t	1 �����Ŵ������ж�    0 ������δ�����ж�
* ע������: ��
******************************************************************************************************************************************/
uint32_t EXTI_State(GPIO_TypeDef * GPIOx, uint32_t n)
{
  return (GPIOx->INTSTAT >> n) & 0x01;
}

/****************************************************************************************************************************************** 
* ���  ����:	EXTI_RawState()
* ���  ˵��:	ָ�������Ƿ������/���жϴ��������������жϹر�ʱ��ͨ�����ô˺����Բ�ѯ�ķ�ʽ����������Ƿ������/���жϴ�������
* ��    ��: GPIO_TypeDef  * GPIOx	ָ�������ⲿ�жϵ�GPIO�˿ڣ���Чֵ����GPIOA��GPIOB��GPIOM
*      uint32_t n        ָ�������ⲿ�жϵ�GPIO���ţ���Чֵ����PIN0��PIN1��PIN2��... ... PIN14��PIN15
* ��    ��:   int32_t	1 �����������/���жϴ�������    0 ������δ�����/���жϴ�������
* ע������: ��
******************************************************************************************************************************************/
uint32_t EXTI_RawState(GPIO_TypeDef * GPIOx, uint32_t n)
{
  return (GPIOx->INTRAWSTAT >> n) & 0x01;
}

/****************************************************************************************************************************************** 
* ���  ����:	EXTI_Clear()
* ���  ˵��:	ָ�������ⲿ�ж������������жϱ�־�������ٴν�����жϣ�
* ��    ��: GPIO_TypeDef  * GPIOx	ָ�������ⲿ�жϵ�GPIO�˿ڣ���Чֵ����GPIOA��GPIOB��GPIOM
*      uint32_t n        ָ�������ⲿ�жϵ�GPIO���ţ���Чֵ����PIN0��PIN1��PIN2��... ... PIN14��PIN15
* ��    ��: ��
* ע������: ֻ��������ش����жϵı�־����ƽ�����жϵı�־�޷������ֻ�������ŵ�ƽ�������жϴ���������Ӳ���Զ����
******************************************************************************************************************************************/
void EXTI_Clear(GPIO_TypeDef * GPIOx, uint32_t n)
{
  GPIOx->INTCLR = (0x01 << n);
}
